plans for tapestry loom rewrite

universal-weave library

rust library containing a universal "loom for anything" library which supporting zero-copy deserialization

two types of Weave: DependentWeave and IndependentWeave

DependentWeave - nodes rely on the contents of previous nodes
IndependentWeave - nodes do not rely on the contents of previous nodes, nodes can have multiple children

Weave<T, U> public fields:
- metadata: U

Node<T>:
- id: Ulid
- bookmarked: bool
- active: bool
- from: HashSet<Ulid>,
- to: HashSet<Ulid>,
- contents: T,

Weave<T> actions:
- new(capacity: usize) -> Self
- get_node(&self, id: Ulid) -> Option<&Node>
- get_roots(&self) -> Vec<Ulid>
- get_bookmarks(&self) -> Vec<Ulid>
- get_active_thread(&self) -> Option<Ulid>
- add_node(&mut self, node: Node) -> bool
- set_node_active_status(&mut self, id: Ulid, value: bool) -> bool
- set_node_bookmarked_status(&mut self, id: Ulid, value: bool) -> bool
- remove_node(&mut self, id: Ulid) -> bool

Weave<T> where T: DiscreteContents actions:
- split_node(&mut self, id: Ulid, at: usize) -> bool
- merge_with_parent(&mut self, id: Ulid) -> bool

Weave<T> where T: DedupableContents actions:
- find_duplicates(&self, id: Ulid) -> Vec<Ulid>

DependentWeave implements TryFrom<IndependentWeave>

IndependentWeave actions:
- move_node(&mut self, target: Ulid, new_parents: Ulid) -> bool

IndependentWeave actions:
- unsafe from_dependent(value: DependentWeave) -> Self


tapestry-weave

rust wasm abstraction over IndependentWeave

provides the following functionality:
- nodes with generation metadata (model used, parameters used, etc...)
- nodes with tokenization metadata (token boundaries, token probabilities, etc...)
- assembling a string w/ tagged metadata from nodes
- updating the weave from a textual diff input